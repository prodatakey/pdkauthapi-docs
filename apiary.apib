FORMAT: 1A
HOST: https://accounts.pdk.io/api

# PDK Auth API
The PDK Auth API is a collection of centralized authentication and authorization endpoints for initiating and managing secure interaction with the suite of PDK APIs.

The Auth API implements a number of standards conforming flows and grants associated with the [OpenID Connect](http://openid.net/connect/) and [OAuth 2.0](http://oauth.net/2/) authentication and authorization standards.
Being familiar with and referencing these standards will be very helpful in understanding the implementation here.

All requests to this API must be protected by SSL, all URLs in this API are availble solely through HTTPS; HTTP requests are refused.

# Client Setup
Before your application can use the system to authenticate users, it must be registered with PDK and assigned a unique `client_id` and `client_secret`.
If you are interested in creating an application that interacts with the PDK APIs, please contact us for more information.

# Discovery Document
The OpenID Connect standard includes a number of endpoints for authentication, requesting tokens, public keys, and other configuration information.
The specification describes a method for dynamically discoverying this information through the use of a discovery document. The discovery document for the PDK Auth API can be found at:

`https://accounts.pdk.io/.well-known/openid-configuration`

Below is an example of the discovery document formatted as defined in the [OpenID Connect Discovery 1.0](http://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata) standard.
While this is a recent copy of the actual document, the values may change.

```
{
    "issuer": "accounts.pdk.io",
    "authorization_endpoint": "https://accounts.pdk.io/oauth2/auth",
    "token_endpoint": "https://accounts.pdk.io/oauth2/token",
    "userinfo_endpoint": "https://accounts.pdk.io/api/users/me/openIdConnect",
    "revocation_endpoint": "https://accounts.pdk.io/oauth2/revoke",
    "jwks_uri": "https://accounts.pdk.io/oauth2/certs",
    "response_types_supported": [ "code" ],
    "subject_types_supported": [ "public" ],
    "id_token_alg_values_supported": [ "RS256" ]
}
```

This document is changed infrequently and may be cached by the client application.
Standard HTTP cache headers are used when delivering the document and should be honored.

# Authentication Flows
There are a number of supported authentication flows that are used with certain application types.

## Installed Applications Flow
This flow is for an application that is installed on a user's desktop computer or mobile device.
The client application must have access to the system browser or a hosted web view in order to facilitate user authentication with this flow.

There are 4 steps to successfully implementing this flow in your application.

1. Direct the user to an authentication URL through a browser that securely stores user cookies.
2. The user authenticates via the interface presented by the PDK authentication system. An authorization code is returned to your application either through a local HTTP endpoint or via the browser's title.
3. Your application, using Basic HTTP auth with the `client_id` and `client_secret`, makes an OOB request to the auth system to exchange that authorization code for an access token and ocassionally a refresh token.
4. The access token can now be used to make requests to PDK API endpoints.

![Auth flow](https://dl.dropbox.com/s/2kc4dvkhab16bfb/installed-app-flow.png)

### 1. Authenticate User
The URL to direct the user to can be found in the discovery document `authorization_endpoint` key.

There are a number of querystring parameters that must be included in this URL to properly authenticate the user and generate an authorization code.

|Parameter | Value | Description |
|----------|-------|-------------|
| response_type | code | This tells the authentication server that your application is expecting an authorization code |
| client_id | The `client_id` assigned to your application | This identifies the application that is requesting access to the user's data |
| redirect_uri | The value to tell the auth system how to return the code | This determines how the access code is communcated to the application. You may choose between `urn:ietf:wg:oauth:2.0:oob` or `http://localhost` with a port number. This is covered in more detail below. |
| scope | openid | A space-separated list of access scopes needed by the application. This should contain the value `openid` to specify an OpenID profile. If the application needs a refresh token for access while the user may be away from their computer, add `offline_access` to the scope list and `prompt=consent` to the URL. |
| state | Any value | This is not required, but is available to round-trip any state information that may be useful to your application. |
| login_hint | email address or sub id | If your application knows what user is authenticating, this parameter will be used by the authentication system to pre-fill the login email. |

#### Example URL

    https://accounts.pdk.io/oauth2/auth?
    response_type=code&
    scope=openid&
    redirect_uri=http://localhost:7446&
    client_id=2a66a379df83b55716a3aee9294ef165

### 2. Get Authorization Code
Once the user successfully authenticates, the authorization code will be returned according to the value specified in the `redirect_uri` parameter.
This can be one of a few ways.

#### Local HTTP Endpoint
If your application can host an HTTP endpoint to recieve the code, this is the preferred method.
Before redirecting the user to the authentication URL, your application should start listening on a random unused local port.
The `redirect_uri` parameter should then specify this port number; for example, if your application is listening on port 4567 then the value should be `http://localhost:4567`.

Once the user successfully authenticates, the browser will be redirected to your HTTP endpoint with the authorization code in the `code` querystring parameter.
The URL will look similar to `http://localhost:4567?code=fc04ddce7bc3435f5e20b9f3f6f8bcce`.

#### Browser Title Bar
An alternate method for receiving the code is for the authentication flow to set the title of the browser once the user successfully authenticates.
This method will be used when your application specifies `urn:ietf:wg:oauth:2.0:oob` for `redirect_uri`.

Once the user successfully authenticates, the title of the browser will be changed and will contain the auhtorization code.
The title value will look like `Success code=fc04ddce7bc3435f5e20b9f3f6f8bcce`

#### Remote HTTP Endpoint
For server side web applications that are able to securely store the `client_id` and `client_secret` behind authenticated endpoints, we can also redirect authentication responses to an https endpoint of the application.

### 3. Exchange Authorization Code
The authorization code is a one-time-use code that your application uses to retrieve an id token which can then be used to make authenticated API requests.
To exchange the authorization code for a token your application needs to make an HTTP POST request to the token endpoint of the auth system.
The token endpoint is located in the discovery document `token_endpoint` key.

To make this request, the application must create a standard HTTP basic authentication header with the `client_id` as the user name and `client_secret` as the password.

#### Request
The request must contain a number of form-urlencoded parameters

| Parameter | Description |
|-----------|-------------|
| code | The authorization code received in the previous step. |
| redirect_uri | The value provided in the previous step. This value is not used for returning the access token in the Installed Application flow but is still required. |
| grant_type | This must contain the value `authorization_code` as specified by the OAuth 2 specification. |

The raw HTTP request may look like this:

```
POST /oauth2/token HTTP/1.1
Host: accounts.pdk.io
Content-Type: application/x-www-form-urlencoded
Basic MmE2NmEzNzlkZjgzYjU1NzE2YTNhZWU5Mjk0ZWYxNjU6eW91cl9jbGllbnRfc2VjcmV0

code=fc04ddce7bc3435f5e20b9f3f6f8bcce&
redirect_uri=https://myapp.example.com/code&
grant_type=authorization_code
```

#### Response

The response to the POST request is JSON formatted data containing the access and refresh tokens.

| Value | Description |
|-------|-------------|
| access_token | The access token that may now be used for making requests only to the user info endpoint (available in the discovery doc). |
| id_token | The token to use for making auth API requests. This is an encoded JWT that contains information on the authenticated user. It is described in the Token Types section. |
| refresh_token | This will be present if the `offline_access` scope was requested. This token is used to get a fresh access token when the current one expires. The refresh token never expires and should be durably and securely stored by your application. |
| token_type | The type of access token returned, this is currently always `Bearer`. |
| expires_in | Expiration time of the Access Token in seconds since the response was generated |

An example JSON encoded response may look like this:

```
{
  "access_token":"SlAV32hkKG"
  "id_token":"eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9...GmUdC2H13YMCwc30Z3l5RCrbwQ",
  "token_type":"Bearer",
  "refresh_token":"76c5cdeecfd1543cfd4c3e7c054780ac",
  "expires_in": 3600
}
```

### 4. Make API Requests
Now that your application has a valid access token it can now use that token to make authenticated requests to PDK APIs.
This is done by simply including the access token in the Bearer type Authorization header of your requests.

The Authorization header should look similar to:

    Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9...GmUdC2H13YMCwc30Z3l5RCrbwQ



## Client Credentials Flow

> **WARNING**: This flow should only be used for Clients that can keep their credentials private and that authorize any requests that make use of the token (e.g. a server-side web application with a login or an API protected by OAuth2).

When used in an application where the client credentials can be kept secure, they can be used to directly retrieve an access token, bearing the Client's identity, from the token endpoint.
The other flows rely on a user delegating their identity instead of the application accessing the API having its own identity.

### Service Account Analog

This authentication flow mimics the concept of a service account.
When enabling this flow, an identity will be created for the client and a role-based permission in a specific OU, similar to a user.

Auth API requests made with a token retrieved using this flow are authorized and audit logged using this identity and are constrained by the applied role and assigned OU(s).

### Setup

The Client must be explicitly enabled to use this flow and is granted on a case-by-case basis.

To create an integration that does not meet the use-cases of the other flows, please reach out to support with information on the application.
The goal of this process is to ensure proper use-case match and to audit that the Client security model meets the needs of the customer.

In your initial contact, please provide as much information as possible on the application use-case requiring this flow and on the authentication and authorization system that the client will be used behind.
Also include an email address that the client's identity should be created under (usually something like support@yourdomain.com), this is the identity the users will see in their audit logs when your software interacts with their systems.

Any user can then simply add a permission for your client's identity, for any desired role, to their OU to grant your application access to their systems.

A member of our developer relations team will follow up with any additional questions or concerns and enable the flow when it is deemed that the solution meets the use-case and security requirements.

### 1. Retrieve The Token
An id token can be used to make authenticated API requests. To retrieve an id token your application needs to make an HTTP POST request to the token endpoint of the auth system.
The token endpoint is located in the discovery document `token_endpoint` key.

To make this request, the application must create a standard HTTP basic authentication header with the `client_id` as the user name and `client_secret` as the password.

#### Request
The request must contain the following form-urlencoded parameter:

| Parameter | Description |
|-----------|-------------|
| grant_type | This must contain the value `client_credentials` as specified by the OAuth 2 specification. |

The raw HTTP request may look like this:

```
POST /oauth2/token HTTP/1.1
Host: accounts.pdk.io
Content-Type: application/x-www-form-urlencoded
Basic MmE2NmEzNzlkZjgzYjU1NzE2YTNhZWU5Mjk0ZWYxNjU6eW91cl9jbGllbnRfc2VjcmV0

grant_type=client_credentials
```

#### Response

The response to the POST request is JSON formatted data containing the access, and id tokens.

| Value | Description |
|-------|-------------|
| access_token | The access token that may now be used for making requests to the user info endpoint. |
| id_token | The token to use for making auth API requests. This is an encoded JWT that contains information on the authenticated user. It is described in the Token Types section. |
| token_type | The type of access token returned, this is currently always `Bearer`. |
| expires_in | Expiration time of the Access Token in seconds since the response was generated |

An example JSON encoded response may look like this:

```
{
  "access_token":"SlAV32hkKG"
  "id_token":"eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9...GmUdC2H13YMCwc30Z3l5RCrbwQ",
  "token_type":"Bearer",
  "expires_in": 3600
}
```

> *NOTE*: This authentication flow does not require the use of refresh tokens as the client can retrieve a fresh token from the token endpoint, without user-interaction, at any time.

### 2. Make API Requests
This valid ID token can now be used to make authenticated requests to the PDK auth APIs.
This is done by including the `id_token` in the Bearer type Authorization header of your requests.

The Authorization header should look similar to:

    Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9...GmUdC2H13YMCwc30Z3l5RCrbwQ



## Implicit Client Flow

The [Implicit Flow](http://openid.net/specs/openid-connect-implicit-1_0.html) is intended for Clients, such as client-side javascript applications, that cannot securely maintain a Client Secret between themselves and the Authorization Server.

### 1. Authenticate User
The URL to direct the user to can be found in the discovery document `authorization_endpoint` key.

There are a number of querystring parameters that must be included in this URL to properly authenticate the user and generate the authorization tokens.

|Parameter | Value | Description |
|----------|-------|-------------|
| response_type | id_token token | This requests that both an Access Token and an ID Token be returned from the Authorization Endpoint |
| client_id | The `client_id` assigned to your application | This identifies the application that is requesting access to the user's data |
| redirect_uri | The value to tell the auth system how to return the code | This determines how the access code is communcated to the application. You may choose between `urn:ietf:wg:oauth:2.0:oob` or `http://localhost` with a port number. This is covered in more detail below. |
| scope | openid | This is for future use and should only contain the value `openid` for now. |
| state | Any value | This is not required, but is available to round-trip any state information that may be useful to your application. This value should be secured against modification. |
| login_hint | email address or sub id | If your application knows what user is authenticating, this parameter will be used by the authentication system to pre-fill the login email. |
| nonce | A cryptographically unique one-time-use token | To mitigate replay attacks, this token must have sufficient entropy. The hash of a cryptographically random value stored in local storage should be sufficient. This is forwarded, unchanged inside the id token, back to the client and should be verified. |

#### Example URL

    https://accounts.pdk.io/oauth2/auth?
        response_type=id_token%20token&
        client_id=2a66a379df83b55716a3aee9294ef165&
        redirect_uri=https://myapp.example.com/cb&
        scope=openid&
        state=af0ifjsldkj
        nonce=n-0S6_WzA2Mj

### 2. Receive Token Response
Once the user successfully authenticates, their user-agent will be redirected back to your client's `redirect_uri`. The tokens and other authentication information are included in the fragment portion of the URI, this is mainly so that those values are not captured in webserver logs.

| Value | Description |
|-------|-------------|
| access_token | The access token that may now be used for making requests to the user info endpoint. |
| id_token | The token to use for making auth API requests. This is an encoded JWT that contains information on the authenticated user. It is described in more detail later. |
| token_type | The type of access token returned, this is currently always `Bearer`. |
| expires_in | Expiration time of the Access Token in seconds since the response was generated. |
| state | Client value included in the `state` parameter of the authentication request. |

    https://myapp.example.com/cb#
        access_token=SlAV32hkKG&
        token_type=bearer&
        id_token=eyJ0 ... NiJ9.eyJ1c ... I6IjIifX0.DeWt4Qu ... ZXso&
        expires_in=3600&
        state=af0ifjsldkj



# Token Types
## Access Token
This is an opaque authentication token that can be used to call the `user_info` endpoint found in the discovery document.
It should be placed in the Authorization header as a Bearer value.

## ID Token
This token is used for accessing the Accounts System APIs (Users, Panels, Org Units).

The ID token that is returned by the authentication flow is a JWT as specified in the [draft IETF standard](http://tools.ietf.org/html/draft-jones-json-web-token-10).
This token contains claims for the authenticated user, an issuer, a target audience, and an expiration time.
These claims include the user's roles, name, email, user id, and other attributes used to identify and authorize certain actions carried out on the user's behalf.

Since this token is digitally signed by the authentication system, the validity of the data in the token can easily be asserted and trusted.
The public keys for verifying the signature of the token are available at the `jwks_uri` key of the discovery document.

The body of a JWT may look like:

```
{
  "io.pdk.roles": [
    "admin",
    "user"
  ],
  "iat": 1402936513,
  "exp": 1402940113,
  "aud": "2a66a379df83b55716a3aee9294ef165",
  "iss": "io.pdk.accounts",
  "sub": "12345567",
  "at_hash": "MTIzNDU2Nzg5MDEyMzQ1Ng"
}
```

**! SECURITY CRITICAL:**
If you rely on data in this token for _any_ reason, be sure to get the certs and verify the signature properly.

If you are only using the token as an opaque Bearer for accessing PDK APIs, there is no need to verify the token in your application.

## Refresh Tokens
When an access token expires the application will need a new one.

If the application requests the scope `offline_access` through any auth flow that supports a refresh token, then a refresh token is provided in the auth flow response. This refresh token is used to request fresh access tokens from the auth system while the user is not actively using the system.

The refresh token should be saved in **secure** durable storage. Though it expires only if the user or PDK revokes access to the application, it is also a consumable.
When consuming a refresh token, a fresh refresh token will be provided in the response alongside the fresh id_token.

Because this could be a rights upgrade, `prompt=consent` must be included any time `offline_access` is in the auth flow request scopes.
This ensures that the user is properly advised of the change.

> **NOTE**:
    Since it is consumable, you must assess if you need to take precautions against consuming it multiple times.
    This is probably necessary to address with multi-instance—including multi-environment (dev,test,prod)—client applications.

Applications that require `offline_access` should be quite rare as this is only needed for accessing the user's system while they are not actively using the requesting application.

## Panel Token

In order to allow secure control of access to hardware in a distributed system, the token that is retrieved from the `panels/<id>/token` is a JWT like the ID token, but while the ID token has an audience specifying the API client, the panel token specifies the specific panel ID.

After validating the JWT signature, the panel will ensure that it is the audience for the provided panel token and deny the request if not.

The other major difference with the panel token is that it expires much more frequently than the other tokens, it is valid for 5 minutes.

## Token Lifetime
For security reasons, these tokens (except the refresh token) expire frequently and will cease to work after they expire.
The application will need to obtain a fresh token in order to continue making authenticated requests to API endpoints.
In the normal case, of an application that is not using `offline_access`, the application will need to process the auth flow in order to retrieve fresh tokens.

#### Request
Requesting a fresh ID token using a refresh token is very similar to exchanging an authorization code for an ID token.
Your application will need to make an HTTP POST request to the token endpoint which can be found in the discovery document `token_endpoint` key.

To make this request, the application must use a standard HTTP basic authentication header with the `client_id` as the user name and `client_secret` as the password used to generate this header.

The request must contain a number of form-urlencoded parameters

| Parameter | Description |
|-----------|-------------|
| refresh_token | This is the persistent refresh token that your application should have received during the initial user authentication. |
| grant_type | This must contain the value `refresh_token` as specified by the OAuth 2 specification. |

The raw HTTP request may look like this:

```
POST /oauth2/token HTTP/1.1
Host: accounts.pdk.io
Content-Type: application/x-www-form-urlencoded
Basic MmE2NmEzNzlkZjgzYjU1NzE2YTNhZWU5Mjk0ZWYxNjU6eW91cl9jbGllbnRfc2VjcmV0

refresh_token=76c5cdeecfd1543cfd4c3e7c054780ac&
grant_type=refresh_token
```

#### Response

The response to the POST request is JSON formatted data containing the fresh access token.

| Value | Description |
|-------|-------------|
| id_token | The token that may now be used for making auth API requests. This is an encoded JWT that is described in more detail in the Token Types section. |
| refresh_token | The refresh token value is consumable. This fresh value should be used in the next refresh request. |
| token_type | The type of access token returned, this is currently always `Bearer`. |

An example JSON encoded response may look like this:

```
{
  "id_token":"eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9...GmUdC2H13YMCwc30Z3l5RCrbwQ",
  "refresh_token":"76c3caeeced2543cfd5c4e8c074790ad",
  "token_type":"Bearer"
}
```

# Account System API

# Group Users
The User entity represents a user login identity used for authentication and authorization against the system.

# Group Panels
The Panel entity represents the configuration of the cloud node customer premise equipment.
This hardware hosts the PDK Panel API, and executes operations of the system at a site.

Registration and enumeration of panels is handled by operations on the OU entities since a panel can only exist as part of an OU.

The panel API endpoint can be resolved by getting the `uri` property of the panel document and appending the path `/api`.
This URI should look similar to `https://panel-1070bbb.pdk.io/api`.

For information on interacting with this API, see the [PDK Panel API documentation](https://pdkapi.docs.apiary.io/).

## Panel [/panels/{id}]
A distinct Panel entity.

+ Parameters

    + id (required, string, `10702MQ`) ... Alphanumeric `id` of the Panel to perform the action on.

+ Model (application/json)

    + `id` (required, string) ... The hardware serial number.
    + `name` (required, string) ... The user-readable name of the panel.
    + `uri` (required, string) ... The URI where the panel can be communicated with.
    + `notes` (required, string) ... User-defined notes.
    + `online` (required, boolean) ... The panel's online state.
    + `registeredDate` (required, string) ... Date and time that the panel was registered.
    + `metadata` (optional, object) ... An optional peice of opaque metadata stored with the entity

    + Body
    
              {
                 "id" : "10702GA",
                 "name" : "🏢 Main Office",
                 "uri" : "https://panel-10702GA.pdk.io/",
                 "notes" : "",
                 "online" : true,
                 "registeredDate" : "2016-04-20T17:29:03.510Z",
                 "metadata": {}
              }
    
### Retrieve a Panel [GET]

+ Response 200

    [Panel][]

### Update a Panel [PUT]
+ Response 204

### Deregister a Panel [DELETE]
+ Response 204

## Panel API Token [/panels/{id}/token]

To access the panel's API endpoint your applicaiton needs to have a valid, unexpired, and discrete auth token.

This token has a lifetime of 5 minutes, a fresh token must be retrieved in order to continue making requests to the panel API.
The limited lifetime works to limit the impact of an exposed token and allows timely revocation of access in a distributed authentication system.

+ Parameters
    + id (required, string, `10702MQ`) ... Alphanumeric `id` of the Panel to perform the action on.

### Generate an API Token [POST]

Generate a time-limited Bearer token for the current user's access to the panel's API.
This token will only work for accessing the panel specified in the `id` parameter.

If there was an unexpired token already generated for this user/panel, that token will be provided.

+ Response 200 (application/json)

        {
            "token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9...GmUdC2H13YMCwc30Z3l5RCrbwQ"
        }


# Group Organizational Units
The Organizational Unit entity is a heirarchical container of user Permissions, Panels, and child Organizational Units.
Each of these entities can only be a member of a single parent OU.

A User is assigned a Permission in an OU to access (according to their roles) all of the Permissions, Panels, and Organizations at their level and deeper in the heirarchy.

In the pdk.io web interface this entity is represented in the UI at `https://pdk.io/systems/{ou_id}`.
The **Customers** collection represents the children of the current OU.

## Organizational Unit [/ous/{ou_id}]

+ Parameters

    + ou_id (required, number) ... Numeric `id` of the OU to perform the action on.

+ Model (application/json)

    + Headers
    
                    
    + Body
    
            {
               "name" : "Integreat Inc.",
               "id" : "55ca2050bbed06f4348b26e8",
               "ancestors" : [
                  "544557759a01deb9874c02ef"
               ],
               "parent" : "544557759a01deb9874c02ef",
               "children" : [
                  {
                     "name" : "Production",
                     "permissions" : [
                        {
                           "role" : "integrator",
                           "userId" : "592457e5cb5f6f00011cc8ee",
                           "email" : "support@prodatakey.com",
                           "name" : "PDK Production",
                           "_id" : "592458c6f570e60001fcefe1"
                        }
                     ],
                     "id" : "592458bacb5f6f00011cc8f8",
                     "panels" : [
                        {
                           "name" : "Rack Mount",
                           "uri" : "https://panel-1070CIX.pdk.io/",
                           "registeredDate" : "2017-06-13T01:01:37.553Z",
                           "id" : "1070CIX"
                        }
                     ]
                  },
                  {
                     "name" : "R&R BBQ 🍖",
                     "id" : "581bac5b530b260001791b6b",
                     "panels" : [],
                     "permissions" : [
                        {
                           "email" : "josh+rr@pdk.io",
                           "userId" : "5821f293530b260001791d15",
                           "name" : "josh perry",
                           "_id" : "5821f277530b260001791d14",
                           "role" : "admin"
                        },
                        {
                           "role" : "manager",
                           "_id" : "5821f2c4530b260001791d17",
                           "name" : "josh perry",
                           "userId" : "5821f2e4530b260001791d18",
                           "email" : "josh+rrman@pdk.io"
                        },
                        {
                           "email" : "josh+rrad@pdk.io",
                           "userId" : "5821f37df4a93000014928fa",
                           "name" : "josh perry",
                           "_id" : "5821f353f4a93000014928f9",
                           "role" : "admin"
                        }
                     ]
                  },
                  {
                     "name" : "🎣 Joe's Bait Shop",
                     "panels" : [],
                     "id" : "57604b80a6a44c1200dba0c9",
                     "permissions" : []
                  }
               ],
               "permissions" : [
                  {
                     "email" : "jordan.mack@gmail.com",
                     "userId" : "584ac92b10e97a0001dbf4d8",
                     "name" : "Jordan Mack",
                     "_id" : "584aca3b10e97a0001dbf4da",
                     "role" : "reporter"
                  },
                  {
                     "role" : "manager",
                     "_id" : "598b6ad6ecb0770001abc31a",
                     "name" : "Greg Corp",
                     "userId" : "57d89535a5f887000195710b",
                     "email" : "gregcorp@xmission.com"
                  }
               ],
               "panels" : [
                  {
                     "uri" : "https://panel-10702GA.pdk.io/",
                     "online" : true,
                     "name" : "🏢 Main Office",
                     "id" : "10702GA",
                     "notes" : "",
                     "registeredDate" : "2016-04-20T17:29:03.510Z"
                  }
               ]
            }

### My OU [GET /ous/mine]

This represents the OU where the currently authenticated user is assigned permission and is commonly used as a root to enumerate all of the entities a user has access to.

+ Response 200

    [Organizational Unit][]

        
### Retrieve an OU [GET]

+ Response 200

    [Organizational Unit][]
    
# Group Webhooks
    
## OU Hooks [/ous/{ou_id}/hooks] 

The functionality is available for [Integrator] roles.

+ Model

    + `name` (required, string) ... Name of the hook. Maximum length is 70.
    + `url` (required, string) ... URL that will be called with events data. HTTPS protocol is required. Should be able to handle POST requests.
    + `scope` (required, array<string> or string) ... Scope of the hook. Scope may contain an explicit list of panel ids to get events from or have one of the special values: 'ou', 'ouRecursive'. Scope 'ou' gives an ability to get events from all cloud nodes within the OU even when membership of that OU changes. Scope 'ouRecursive' acts similarly, but is applied to children in addition to the OU where the hook is registered.
    + `authentication` (required, object) ... Object that specifies authentication mechanism to be used in POST requests. Field `type` is required. Possible values: 'None', 'Basic'. 'None' means no authentication. 'Basic' means Basic authentication. For the 'Basic' type, 'user' and 'password' fields are required.
    + `secret` (optional, string) ... Secret of the hook. Maximum length is 255. If specified, header X_PDK_SIGNATURE will be present in request. This header will contain SHA-1 HMAC calculated using the secret value.
    + `events` (required, array[string]) ... Specific events to subscribe to. Events come in two types, panel events and OU events. Panel events refer to the activity on the cloud nodes. OU events refer to the management activity within the organization. Panel and OU events can't be present together for one hook. For OU events, only 'ou' and 'ouRecursive' scopes are valid. Panel events can be applied to any scope.  Descriptions for each event can be found in a later section of this document.
        + Panel events
            + `door.input.dps.opened`,
            + `door.input.dps.closed`,
            + `door.input.rex.on`,
            + `door.input.rex.off`,
            + `door.input.relay.on`,
            + `door.input.relay.off`,
            + `door.input.virtualread`,
            + `door.forceopen.on`,
            + `door.forceopen.off`,
            + `door.forceclose.on`,
            + `door.forceclose.off`,
            + `door.autoopen.on`,
            + `door.autoopen.off`,
            + `door.autoopen.override.on`,
            + `door.autoopen.override.off`,
            + `door.alarm.propped.on`,
            + `door.alarm.propped.off`,
            + `door.alarm.propped.alloff`,
            + `door.alarm.forced`,
            + `door.alarm.forced.cleared`,
            + `door.request.unknown`,
            + `door.request.found`,
            + `door.request.allowed`,
            + `door.request.multiallowed`,
            + `door.request.denied`,
            + `door.request.duress`,
            + `endpoint.input.pi.on`,
            + `endpoint.input.pi.off`,
            + `endpoint.input.pi.status`,
            + `endpoint.input.pp.status`,
            + `endpoint.input.pb.status`,
            + `endpoint.input.pb.connected`,
            + `endpoint.input.pb.disconnected`,
            + `endpoint.input.bh.state`,
            + `endpoint.input.po.present`,
            + `endpoint.input.po.absent`,
            + `endpoint.input.lp.on`,
            + `endpoint.input.lp.off`,
            + `endpoint.alarm.comloss.on`,
            + `endpoint.alarm.comloss.off`,
            + `endpoint.added`,
            + `endpoint.deleted`,
            + `error.card.parse`,
            + `error.packetized.protocol`,
            + `notification.person.created`,
            + `notification.person.updated`,
            + `notification.person.deleted`,
            + `notification.intercom.created`,
            + `notification.intercom.updated`,
            + `notification.intercom.deleted`,
            + `notification.client.command`,
            + `notification.device.created`,
            + `notification.device.updated`,
            + `notification.device.deleted`,
            + `entity.added`,
            + `entity.modified`,
            + `entity.removed`,
            + `floorgroup.activated`,
            + `panel.connected`,
            + `panel.disconnected`
        + OU events
            + `ou.created`,
            + `ou.updated`,
            + `ou.deleted`,
            + `panel.created`,
            + `panel.updated`,
            + `panel.deleted`,
            + `permission.created`,
            + `permission.deleted`
    + `active` (optional, boolean) ... Status of the hook. Default value is `true`. If `false` is set the hook URL will never be called.
    + `expiresAt` (optional, string) ... Timestamp when this hook's active status will be set to false.. This field can only be set to values in the future..
    + `sslVerification` (optional, boolean) … If enabled, the SSL certificate of the server that handles hook URL will be checked. Setting this parameter to `false` will allow usage of self-signed certificates by the server. Default value is `true`.
    + `secrecyLevel` (optional, number) ... Allows control over the sensitivity of information that will be passed in the event body to the external URL.  If you don’t know what secrecyLevel you need set to 2 and lower only as your use cases dictate.  
        + Default: `1`
        + Members
            + `0` - all information.
            + `1` - no security info (pin, card number).
            + `2` - remove all filtered by 1 plus no personal info (people names).

    + Headers
    
            Authorization: Bearer {token}
    
    + Body
    
            {
                "id": "5f5f732e54760008587fe4c3",
                "name": "hookName",
                "url": "https://mywebsite.com",
                "scope": "ou",
                "secret": "gu8fHEzB1sMNXCaoTiAm",
                "authentication": {
                    "type": "Basic",
                    "user": "guest",
                    "password": "guest"
                },
                "events": [
                    "door.input.rex.off"
                ],
                "active": true,
                "sslVerification": true,
                "expiresAt": "2022-02-01 22:23:11 UTC-6",
                "secrecyLevel": 2
            }


### Retrieve all Hooks [GET /ous/{ou_id}/hooks]

+ Parameters

    + ou_id (required, string) 
        `id` of the OU.

+ Request

    + Headers
    
            Authorization: Bearer {token}

+ Response 200 (application/json)

    + `id` (required, string) ... `id` of the Hook.
    + `name` (required, string) ... Name of the Hook.
    + `url` (required, string) ... URL of the hook.
    + `scope` (required, string or array[string]) ... Scope of the hook.
    + `authentication` (required, object) ... Authentication information of the hook: type and details.
    + `secret` (optional, string) ... Secret of the hook.
    + `events` (required, array[string]) ... Events to subscribe to.
    + `active` (required, boolean) ... Status of the hook.
    + `expiresAt` (required, string) ... Timestamp when  this hook’s active status will be set to false.
    + `sslVerification` (optional, boolean) … Enabled/disabled SSL certificate verification.
    + `secrecyLevel` (required, number) ... What information will be shown in the event's body.

    + Headers
    
    + Body
    
            [
                {
                    "id": "5f5f732e54760008587fe4c6",
                    "name": "firstHook",
                    "url": "https://mywebsite.com",
                    "scope": "ouRecursive",
                    "secret": "gu8fHEzB1sMNXCaoTiAm23we",
                    "authentication": {
                        "type": "Basic",
                        "user": "userName",
                        "password": "12345"
                    },
                    "events": [
                        "door.input.rex.off",
                        "error.packetized.protocol",
                        "endpoint.added"
                    ],
                    "active": true,
                    "sslVerification": true,
                    "expiresAt": "2023-08-01 22:23:11 UTC-6",
                    "secrecyLevel": 1
                },
                {
                    "id": "5f5f732e54760008587fe496",
                    "name": "secondHook",
                    "url": "https://mywebsite.com",
                    "scope": "ou",
                    "secret": "EzB1sMNXCaoTiAm",
                    "authentication": {
                        "type": "None"
                    },
                    "events": [
                        "ou.created",
                        "ou.updated",
                        "permission.created"
                    ],
                    "active": false,
                    "expiresAt": "2022-02-01 22:23:11 UTC-6",
                    "sslVerification": true,
                    "secrecyLevel": 2
                }
            ]

+ Response 400 (application/json)
+ Response 401 (application/json)
+ Response 403 (application/json)
+ Response 404 (application/json)

### Retrieve a Hook [GET /ous/{ou_id}/hooks/{hook_id}]

+ Parameters

    + ou_id (required, string) ... `id` of the OU.
    + hook_id (required, string) ... `id` of the Hook.

+ Request

    + Headers
    
            Authorization: Bearer {token}

+ Response 200 (application/json)

    + `id` (required, string) ... `id` of the Hook.
    + `name` (required, string) ... Hook name.
    + `url` (required, string) ... URL the hook will call.
    + `scope` (required, string or array[string]) ... Scope of the hook.
    + `authentication` (required, object) ... Authentication information of the hook.
    + `secret` (optional, string) ... Secret.
    + `events` (required, array[string]) ... List of events.
    + `active` (required, boolean) ... Status of the hook.
    + `expiresAt` (required, string) ... Timestamp when  this hook’s active status will be set to false.
    + `sslVerification` (optional, boolean) … Enabled/disabled SSL certificate verification.
    + `secrecyLevel` (required, number) ... Level of the hook.
    
    + Body
    
            {
                "id": "5f5f732e54760008587fe496",
                "name": "secondHook",
                "url": "https://mywebsite.com",
                "scope": "ou",
                "secret": "EzB1sMNXCaoTiAm",
                "authentication": {
                    "type": "None"
                },
                "events": [
                    "ou.created",
                    "ou.updated",
                    "permission.created"
                ],
                "active": false,
                "sslVerification": true,
                "expiresAt": "2022-02-01 22:23:11 UTC-6",
                "secrecyLevel": 2
            }

+ Response 400 (application/json)
+ Response 401 (application/json)
+ Response 403 (application/json)
+ Response 404 (application/json)

### Create a Hook [POST]
+ Parameters

    + ou_id (required, string) ... `id` of the OU.
    
+ Request (application/json)

    [OU Hooks][]

+ Response 201 (application/json)
+ Response 400 (application/json)
+ Response 401 (application/json)
+ Response 403 (application/json)
+ Response 404 (application/json)

### Update a Hook [PUT /ous/{ou_id}/hooks/{hook_id}]

+ Parameters

    + ou_id (required, string) ... `id` of the OU.
    + hook_id (required, string) ... `id` of the Hook.

+ Request

 
    + `name` (required, string) ... Name of the Hook.
    + `url` (required, string) ... URL the hook will call.
    + `scope` (required, string or array[string]) ... Scope of the hook. The scope shouldn't be changed from 'ou' or 'ouRecursive' to array of panels and vice versa.
    + `authentication` (required, object) ... Authentication information of the hook: type and details.
    + `secret` (optional, string) ... Secret of the hook.
    + `events` (required, array[string]) ... Events to subscribe to. All events should belong to the same group: panel events orOU events.
    + `active` (required, boolean) ... Status of the hook.
    + `expiresAt` (required, string) ... Timestamp when  this hook’s active status will be set to false.
    + `sslVerification` (optional, boolean) … Enabled/disabled SSL certificate verification.
    + `secrecyLevel` (required, number) ... What information will be shown in the event's body.

    + Headers
    
            Authorization: Bearer {token}

+ Response 204 (application/json)
+ Response 400 (application/json)
+ Response 401 (application/json)
+ Response 403 (application/json)
+ Response 404 (application/json)

### Delete a Hook [DELETE /ous/{ou_id}/hooks/{hook_id}]
+ Parameters

    + ou_id (required, string) ... `id` of the OU.
    + hook_id (required, string) ... `id` of the Hook.

+ Request

    + Headers
    
            Authorization: Bearer {token}

+ Response 204
+ Response 400 (application/json)
+ Response 401 (application/json)
+ Response 403 (application/json)
+ Response 404 (application/json)

## Panel Hooks [/panels/{panel_id}/hooks]

The functionality is available for [Integrator] roles.

+ Model

    + `name` (required, string) ... Name of the hook. Maximum length is 70.
    + `url` (required, string) ... URL that will be called with events data. HTTPS protocol is required. Should be able to handle POST requests.
    + `authentication` (required, object) ... Object that specifies authentication mechanism to be used in POST requests. Field `type` is required. Possible values: 'None', 'Basic'. 'None' means no authentication. 'Basic' means Basic authentication. For 'Basic' type, 'user' and 'password' fields are required.
    + `secret` (optional, string) ... Secret of the hook. Maximum length is 255. If specified, header X_PDK_SIGNATURE will be present in request. This header will contain SHA-1 HMAC calculated using the secret value.
    + `events` (required, array[string]) ... Panel events.
        + Members
            + `door.input.dps.opened`,
            + `door.input.dps.closed`,
            + `door.input.rex.on`,
            + `door.input.rex.off`,
            + `door.input.relay.on`,
            + `door.input.relay.off`,
            + `door.input.virtualread`,
            + `door.forceopen.on`,
            + `door.forceopen.off`,
            + `door.forceclose.on`,
            + `door.forceclose.off`,
            + `door.autoopen.on`,
            + `door.autoopen.off`,
            + `door.autoopen.override.on`,
            + `door.autoopen.override.off`,
            + `door.alarm.propped.on`,
            + `door.alarm.propped.off`,
            + `door.alarm.propped.alloff`,
            + `door.alarm.forced`,
            + `door.alarm.forced.cleared`,
            + `door.request.unknown`,
            + `door.request.found`,
            + `door.request.allowed`,
            + `door.request.multiallowed`,
            + `door.request.denied`,
            + `door.request.duress`,
            + `endpoint.input.pi.on`,
            + `endpoint.input.pi.off`,
            + `endpoint.input.pi.status`,
            + `endpoint.input.pp.status`,
            + `endpoint.input.pb.status`,
            + `endpoint.input.pb.connected`,
            + `endpoint.input.pb.disconnected`,
            + `endpoint.input.bh.state`,
            + `endpoint.input.po.present`,
            + `endpoint.input.po.absent`,
            + `endpoint.input.lp.on`,
            + `endpoint.input.lp.off`,
            + `endpoint.alarm.comloss.on`,
            + `endpoint.alarm.comloss.off`,
            + `endpoint.added`,
            + `endpoint.deleted`,
            + `error.card.parse`,
            + `error.packetized.protocol`,
            + `notification.person.created`,
            + `notification.person.updated`,
            + `notification.person.deleted`,
            + `notification.intercom.created`,
            + `notification.intercom.updated`,
            + `notification.intercom.deleted`,
            + `notification.client.command`,
            + `notification.device.created`,
            + `notification.device.updated`,
            + `notification.device.deleted`,
            + `entity.added`,
            + `entity.modified`,
            + `entity.removed`,
            + `floorgroup.activated`,
            + `panel.connected`,
            + `panel.disconnected`
    + `active` (optional, boolean) ... Status of the hook. Default value is `true`. If `false` is set, the hook URL will never be called.
    + `expiresAt` (optional, string) ... Timestamp when this hook’s active status will be set to false. This field can only be set to values in the future.
    + `sslVerification` (optional, boolean) … If enabled, the SSL certificate of the server that handles hook URL will be checked. Setting this parameter to `false` will allow usage of self-signed certificates by the server. Default value is `true`.
    + `secrecyLevel` (optional, number) ... Allows control over the sensitivity of information that will be passed in the event body to the external URL.  If you don’t know what secrecyLevel you need set to 2 and lower only as your use cases dictate.
        + Default: `1`
        + Members
            + `0` - all information.
            + `1` - no security info (pin, card number).
            + `2` - remove all filtered by 1 plus no personal info (people names).

    + Headers
    
            Authorization: Bearer {token}
    
    + Body
    
            {
                "id": "5f5f732e54760008587fe4c3",
                "name": "hookName",
                "url": "https://mywebsite.com",
                "secret": "gu8fHEzB1sMNXCaoTiAm",
                "authentication": {
                    "type": "None"
                },
                "events": [
                    "door.alarm.propped.on"
                ],
                "active": true,
                "expiresAt": "2022-02-01 22:23:11 UTC-6",
                “sslVerification”: true,
                "secrecyLevel": 2
            }


### Retrieve all Hooks [GET /panels/{panel_id}/hooks]

+ Parameters

    + panel_id (required, string) 
        `id` of the Panel.

+ Request

    + Headers
    
            Authorization: Bearer {token}

+ Response 200 (application/json)

    + `id` (required, string) ... `id` of the Hook.
    + `name` (required, string) ... Name of the Hook.
    + `url` (required, string) ... URL of the hook.
    + `scope` (required, string or array[string]) ... Scope of the hook.
    + `authentication` (required, object) ... Authentication information of the hook: type and details.
    + `secret` (optional, string) ... Secret of the hook.
    + `events` (required, array[string]) ... Events to subscribe to.
    + `active` (required, boolean) ... Status of the hook.
    + `expiresAt` (required, string) ... Timestamp when this hook’s active status will be set to false.
    + `sslVerification` (optional, boolean) … Enabled/disabled SSL certificate verification.
    + `secrecyLevel` (required, number) ... What information will be shown in the event's body.

    + HeadersCorrec
    
    + Body
    
            [
                {
                    "id": "5f5f732e54760008587fe4c6",
                    "name": "firstHook",
                    "url": "https://mywebsite.com",
                    "scope": ["14402II"],
                    "secret": "gu8fHEzB1sMNXCaoTiAm23we",
                    "authentication": {
                        "type": "Basic",
                        "user": "userName",
                        "password": "12345"
                    },
                    "events": [
                        "error.packetized.protocol",
                        "endpoint.added"
                    ],
                    "active": true,
                    "expiresAt": "2023-08-01 22:23:11 UTC-6",
                    "sslVerification": true,
                    "secrecyLevel": 1
                },
                {
                    "id": "5f5f732e54760008587fe496",
                    "name": "secondHook",
                    "url": "https://mywebsite.com",
                    "scope": ["14402II", "13402II"],
                    "secret": "EzB1sMNXCaoTiAm",
                    "authentication": {
                        "type": "None"
                    },
                    "events": [
                        "door.input.rex.on",
                        "door.input.rex.off"
                    ],
                    "active": true,
                    "expiresAt": "2022-02-01 22:23:11 UTC-6",
                   "sslVerification": true,
                    "secrecyLevel": 2
                }
            ]

+ Response 400 (application/json)
+ Response 401 (application/json)
+ Response 403 (application/json)
+ Response 404 (application/json)

### Retrieve a Hook [GET /panels/{panel_id}/hooks/{hook_id}]

+ Parameters

    + panel_id (required, string) ... `id` of the Panel.
    + hook_id (required, string) ... `id` of the Hook.

+ Request

    + Headers
    
            Authorization: Bearer {token}

+ Response 200 (application/json)
    + `id` (required, string) ... `id` of the Hook.
    + `name` (required, string) ... Name of the Hook.
    + `url` (required, string) ... URL of the hook.
    + `scope` (required, string or array[string]) ... Scope of the hook.
    + `authentication` (required, object) ... Authentication information of the hook: type and details.
    + `secret` (optional, string) ... Secret of the hook.
    + `events` (required, array[string]) ... Events to subscribe to.
    + `active` (required, boolean) ... Status of the hook.
    + `sslVerification` (optional, boolean) … Enabled/disabled SSL certificate verification.
    + `expiresAt` (required, string) ... Timestamp when this hook’s active status will be set to false.
    + `secrecyLevel` (required, number) ... What information will be shown in the event's body.
    
    + Body
    
            {
                "id": "5f5f732e54760008587fe496",
                "name": "secondHook",
                "url": "https://mywebsite.com",
                "scope": ["13402II"],
                "secret": "EzB1sMNXCaoTiAm",
                "authentication": {
                    "type": "None"
                },
                "events": [
                    "door.input.rex.on"
                ],
                "active": false,
                "expiresAt": "2022-02-01 22:23:11 UTC-6",
                "sslVerification": true,
                "secrecyLevel": 2
            }

+ Response 400 (application/json)
+ Response 401 (application/json)
+ Response 403 (application/json)
+ Response 404 (application/json)

### Create a Hook [POST]
+ Parameters

    + panel_id (required, string) ... `id` of the Panel.
    
+ Request (application/json)

    [OU Hooks][]

+ Response 204
+ Response 400 (application/json)
+ Response 401 (application/json)
+ Response 403 (application/json)
+ Response 404 (application/json)

### Update a Hook [PUT /panels/{panel_id}/hooks/{hook_id}]

+ Parameters

    + panel_id (required, string) ... `id` of the Panel.
    + hook_id (required, string) ... `id` of the Hook.

+ Request

    + `name` (required, string) ... Name of the Hook.
    + `url` (required, string) ... URL of the hook.
    + `authentication` (required, object) ... Authentication information of the hook: type and details.
    + `secret` (optional, string) ... Secret of the hook.
    + `events` (required, array[string]) ... Events to subscribe to.
    + `active` (required, boolean) ... Status of the hook.
    + `expiresAt` (required, string) ... Timestamp when  this hook’s active status will be set to false.
    + `sslVerification` (optional, boolean) … Enabled/disabled SSL certificate verification.
    + `secrecyLevel` (required, number) ... What information will be shown in the event's body.

    + Headers
    
            Authorization: Bearer {token}

+ Response 204 (application/json)
+ Response 400 (application/json)
+ Response 401 (application/json)
+ Response 403 (application/json)
+ Response 404 (application/json)

### Delete a Hook [DELETE /panels/{panel_id}/hooks/{hook_id}]
+ Parameters

    + panel_id (required, string) ... `id` of the Panel.
    + hook_id (required, string) ... `id` of the Hook.

+ Request

    + Headers
    
            Authorization: Bearer {token}

+ Response 204
+ Response 400 (application/json)
+ Response 401 (application/json)
+ Response 403 (application/json)
+ Response 404 (application/json)

# Group Webhook events

## Panel events

Here is a short description of all events that can be generated by the system. Details on the specific event can be found within the body of the transmitted message.

### door.input.dps.opened
DPS (Input A) sensor on a device reports OPEN state.
### door.input.dps.closed
DPS (Input A) sensor on a device reports CLOSE state.
### door.input.rex.on
Request to Exit (Input B) button is pressed.
### door.input.rex.off
Request to Exit (Input B) button is released.
### door.input.relay.on
Relay on a device is deactivated (lock open).
### door.input.relay.off
Relay on a device is activated (lock close).
### door.input.virtualread
Emulated credential scan was used on a device. Happens when the device is activated remotely by a person (not a pdk.io website user) for example  activating a device from the Touch app.
### door.forceopen.on
Indicates that Force Open state is enabled on a device. Happens when an event rule with the “Force Open” action is triggered.
### door.forceopen.off
Indicates that Force Open state is disabled on a device.
### door.forceclose.on
Indicates that Force Close state is enabled on a device. Happens when an event rule with the “Force Close” action is triggered.
### door.forceclose.off
Indicates that Force Close state is disabled on a device.
### door.autoopen.on
Indicates that a device moved to Auto Open On state. This doesn’t necessarily mean that device is open (it depends on the configuration), but only that there is an active auto open rule for this device.
### door.autoopen.off
Indicates that a device moved to Auto Open Off state. Lock will be closed on this device.
### door.autoopen.override.on
Indicates that active Auto Open state was overridden.
### door.autoopen.override.off
Indicates that Auto Open override was cleared.
### door.alarm.propped.on
Prop Alarm activated for a device.
### door.alarm.propped.off
Prop Alarm cleared for a device.
### door.alarm.propped.alloff
Prop Alarm was cleared for all devices in the system.
### door.alarm.forced
Force Alarm activated for a device.
### door.alarm.forced.cleared
Force Alarm was cleared for a device.
### door.request.unknown
Credential scan received from a device, but there is no person associated with this credential.
### door.request.found
Credential scan received from a device, there is a person in the system associated with this credential.
### door.request.allowed
Access granted after a credential scan.
### door.request.multiallowed
Access granted after multiple sequential credential scans.
### door.request.denied
Credential scan associated with a person received but that person doesn’t have access.
### door.request.duress
Duress PIN was used to access a device.
### endpoint.input.pi.on
Input power connected to a controller.
### endpoint.input.pi.off
Input power was disconnected from a controller.
### endpoint.input.pi.status
Extended information about input power on a controller (voltage, current).
### endpoint.input.pp.status
Extended information about peripheral power on a controller (voltage, current).
### endpoint.input.pb.status
Extended information about battery on a controller (charge level, time to full/empty, current).
### endpoint.input.pb.connected
Battery was connected to a controller.
### endpoint.input.pb.disconnected
Battery was disconnected from a controller.
### endpoint.input.bh.state
Information about controller’s battery health (Ok/Bad)
### endpoint.input.po.present
Overcurrent detected on a controller.
### endpoint.input.po.absent
No overcurrent on a controller anymore.
### endpoint.input.lp.on
Controller moved to a Low Power Mode state.
### endpoint.input.lp.off
Controlled moved to a normal state from Low Power Mode.
### endpoint.alarm.comloss.on
Communication with a controller was lost.
### endpoint.alarm.comloss.off
Communication restored with a controller.
### endpoint.added
New controller’s port is used (either new device or existing device updated).
### endpoint.deleted
Some controller’s port is not used anymore (corresponding device deleted or its port changed).
### error.card.parse
Error happened during credential scan processing when custom card format is used.
### error.packetized.protocol
Error happened during processing credential input from Bluetooth reader.
### notification.person.created
New person was added to the system.
### notification.person.updated
Person entity was changed. Only direct person fields are checked here, person credentials, groups and changes to rules will not cause this event to fire. Use `entity.modified` to get such events.
### notification.person.deleted
Person was removed from the system.
### notification.intercom.created
New intercom was added.
### notification.intercom.updated
Intercom information was changed.
### notification.intercom.deleted
Intercom was removed from the system.
### notification.client.command
Command was sent via WebSocket connection (usually from pdk.io website).
### notification.device.created
New device was configured.
### notification.device.updated
Device entity was changed.
### notification.device.deleted
Device was deleted.
### entity.added
New entity (Person/Group/Credential/Rule/CardFormat/Elevator/Device/Connection/Partition) was added to the system.
### entity.modified
Entity was changed. Includes dependent entities updates, like person was added to a group, device was removed from a rule.
### entity.removed
Entity was removed from the system.
### floorgroup.activated
Floor group (elevators) was activated.
### panel.connected
Cloud node has established a connection to the cloud.
### panel.disconnected
Cloud node connection to the cloud has been severed.

## OU events

Here is a short description of all events that can be generated by the system. Details on the specific event can be found within the body of the transmitted message.

### ou.created
New customer organization was added.
### ou.updated
Organization was updated (name changed, optional features enabled/disabled)
### ou.deleted
Organization was removed from the system.
### panel.created
New cloud node was added to an organization.
### panel.updated
Cloud node was changed (name or description changed).
### panel.deleted
Cloud node was removed from an organization.
### permission.created
New user permission was granted.
### permission.deleted
User permission was revoked.