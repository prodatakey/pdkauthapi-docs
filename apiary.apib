FORMAT: 1A
HOST: https://accounts.pdk.io/api

# PDK Auth API
The PDK Auth API is a collection of centralized authentication and authorization endpoints for initiating and managing secure interaction with the suite of PDK APIs.

The Auth API implements a number of standards conforming flows and grants associated with the [OpenID Connect](http://openid.net/connect/) and [OAuth 2.0](http://oauth.net/2/) authentication and authorization standards.
Being familiar with and referencing these standards will be very helpful in understanding the implementation here.

All requests to this API must be protected by SSL, all URLs in this API are availble solely through HTTPS; HTTP requests are refused.

# Client Setup
Before your application can use the system to authenticate users, it must be registered with PDK and assigned a unique `client_id` and `client_secret`.
If you are interested in creating an application that interacts with the PDK APIs, please contact us for more information.

# Discovery Document
The OpenID Connect standard includes a number of endpoints for authentication, requesting tokens, public keys, and other configuration information.
The specification describes a method for dynamically discoverying this information through the use of a discovery document. The discovery document for the PDK Auth API can be found at:

`https://accounts.pdk.io/.well-known/openid-configuration`

Below is an example of the discovery document formatted as defined in the [OpenID Connect Discovery 1.0](http://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata) standard.
While this is a recent copy of the actual document, the values may change.

```
{
    "issuer": "accounts.pdk.io",
    "authorization_endpoint": "https://accounts.pdk.io/oauth2/auth",
    "token_endpoint": "https://accounts.pdk.io/oauth2/token",
    "userinfo_endpoint": "https://accounts.pdk.io/api/users/me/openIdConnect",
    "revocation_endpoint": "https://accounts.pdk.io/oauth2/revoke",
    "jwks_uri": "https://accounts.pdk.io/oauth2/certs",
    "response_types_supported": [ "code" ],
    "subject_types_supported": [ "public" ],
    "id_token_alg_values_supported": [ "RS256" ]
}
```

This document is changed infrequently and may be cached by the client application.
Standard HTTP cache headers are used when delivering the document and should be honored.

# Authentication Flows
There are a number of supported authentication flows that are used with certain application types.

## Installed Applications Flow
This flow is for an application that is installed on a user's desktop computer or mobile device.
The client application must have access to the system browser or a hosted web view in order to facilitate user authentication with this flow.

There are 4 steps to successfully implementing this flow in your application.

1. Direct the user to an authentication URL through a browser that securely stores user cookies.
2. The user authenticates via the interface presented by the PDK authentication system. An authorization code is returned to your application either through a local HTTP endpoint or via the browser's title.
3. Your application, using Basic HTTP auth with the `client_id` and `client_secret`, makes an OOB request to the auth system to exchange that authorization code for an access token and ocassionally a refresh token.
4. The access token can now be used to make requests to PDK API endpoints.

![Auth flow](https://dl.dropbox.com/s/2kc4dvkhab16bfb/installed-app-flow.png)

### 1. Authenticate User
The URL to direct the user to can be found in the discovery document `authorization_endpoint` key.

There are a number of querystring parameters that must be included in this URL to properly authenticate the user and generate an authorization code.

|Parameter | Value | Description |
|----------|-------|-------------|
| response_type | code | This tells the authentication server that your application is expecting an authorization code |
| client_id | The `client_id` assigned to your application | This identifies the application that is requesting access to the user's data |
| redirect_uri | The value to tell the auth system how to return the code | This determines how the access code is communcated to the application. You may choose between `urn:ietf:wg:oauth:2.0:oob` or `http://localhost` with a port number. This is covered in more detail below. |
| scope | openid | A space-separated list of access scopes needed by the application. This should contain the value `openid` to specify an OpenID profile. If the application needs a refresh token for access while the user may be away from their computer, add `offline_access` to the scope list and `prompt=consent` to the URL. |
| state | Any value | This is not required, but is available to round-trip any state information that may be useful to your application. |
| login_hint | email address or sub id | If your application knows what user is authenticating, this parameter will be used by the authentication system to pre-fill the login email. |

#### Example URL

    https://accounts.pdk.io/oauth2/auth?
    response_type=code&
    scope=openid&
    redirect_uri=http://localhost:7446&
    client_id=2a66a379df83b55716a3aee9294ef165

### 2. Get Authorization Code
Once the user successfully authenticates, the authorization code will be returned according to the value specified in the `redirect_uri` parameter.
This can be one of a few ways.

#### Local HTTP Endpoint
If your application can host an HTTP endpoint to recieve the code, this is the preferred method.
Before redirecting the user to the authentication URL, your application should start listening on a random unused local port.
The `redirect_uri` parameter should then specify this port number; for example, if your application is listening on port 4567 then the value should be `http://localhost:4567`.

Once the user successfully authenticates, the browser will be redirected to your HTTP endpoint with the authorization code in the `code` querystring parameter.
The URL will look similar to `http://localhost:4567?code=fc04ddce7bc3435f5e20b9f3f6f8bcce`.

#### Browser Title Bar
An alternate method for receiving the code is for the authentication flow to set the title of the browser once the user successfully authenticates.
This method will be used when your application specifies `urn:ietf:wg:oauth:2.0:oob` for `redirect_uri`.

Once the user successfully authenticates, the title of the browser will be changed and will contain the auhtorization code.
The title value will look like `Success code=fc04ddce7bc3435f5e20b9f3f6f8bcce`

#### Remote HTTP Endpoint
For server side web applications that are able to securely store the `client_id` and `client_secret` behind authenticated endpoints, we can also redirect authentication responses to an https endpoint of the application.

### 3. Exchange Authorization Code
The authorization code is a one-time-use code that your application uses to retrieve an access token which can then be used to make authenticated API requests.
To exchange the authorization code for an access token your application needs to make an HTTP POST request to the token endpoint of the auth system.
The token endpoint is located in the discovery document `token_endpoint` key.

To make this request, the application must create a standard HTTP basic authentication header with the `client_id` as the user name and `client_secret` as the password.

#### Request
The request must contain a number of form-urlencoded parameters

| Parameter | Description |
|-----------|-------------|
| code | The authorization code received in the previous step. |
| redirect_uri | The value provided in the previous step. This value is not used for returning the access token in the Installed Application flow but is still required. |
| grant_type | This must contain the value `authorization_code` as specified by the OAuth 2 specification. |

The raw HTTP request may look like this:

```
POST /oauth2/token HTTP/1.1
Host: accounts.pdk.io
Content-Type: application/x-www-form-urlencoded
Basic MmE2NmEzNzlkZjgzYjU1NzE2YTNhZWU5Mjk0ZWYxNjU6eW91cl9jbGllbnRfc2VjcmV0

code=fc04ddce7bc3435f5e20b9f3f6f8bcce&
redirect_uri=https://myapp.example.com/code&
grant_type=authorization_code
```

#### Response

The response to the POST request is JSON formatted data containing the access and refresh tokens.

| Value | Description |
|-------|-------------|
| access_token | The access token that may now be used for making authenticated API requests. |
| id_token |  This is an encoded JWT that contains information on the authenticated user. It is described in more detail later. |
| refresh_token | This will be present if the `offline_access` scope was requested. This token is used to get a fresh access token when the current one expires. The refresh token never expires and should be durably and securely stored by your application. |
| token_type | The type of access token returned, this is currently always `Bearer`. |
| expires_in | Expiration time of the Access Token in seconds since the response was generated |

An example JSON encoded response may look like this:

```
{
  "access_token":"SlAV32hkKG"
  "id_token":"eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9...GmUdC2H13YMCwc30Z3l5RCrbwQ",
  "token_type":"Bearer",
  "refresh_token":"76c5cdeecfd1543cfd4c3e7c054780ac",
  "expires_in": 3600
}
```

### 4. Make API Requests
Now that your application has a valid access token it can now use that token to make authenticated requests to PDK APIs.
This is done by simply including the access token in the Bearer type Authorization header of your requests.

The Authorization header should look similar to:

    Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9...GmUdC2H13YMCwc30Z3l5RCrbwQ



## Client Credentials Flow

> **WARNING**: This flow should only be used for Clients that can keep their credentials private and that authorize any requests that make use of the token (e.g. a server-side web application or API protected by OAuth2).

When used in an application where the client credentials can be kept secure, they can be used to directly retrieve an access token, bearing the Client's identity, from the token endpoint.

### Service Account Analog

This authentication flow mimics the concept of a service account. When enabling this flow, the client will also be assigned an identity and a role-based permission in a specific container, similar to a user.

Auth API requests made with a token retrieved using this flow are authorized and audit logged using this client identity and are constrained by the applied role and assigned container.

### Setup

The Client must be explicitly enabled to use this flow and is granted on a case-by-case basis.

To create an integration that does not meet the use-cases of the other flows, please reach out to support with information on the application.
The goal of this process is to ensure proper use-case match and to audit that the Client security model meets the needs of the customer.

In your initial contact, please provide as much information as possible on the application use-case requiring this flow and on the authentication and authorization system that the client will be used behind.
Also include the role and container ID where the client's permission should be granted.

A member of our developer relations team will follow up with any additional questions or concerns and enable the flow when it is deemed that the solution meets the use-case and security requirements.

### 1. Retrieve Access Token
An access token can be used to make authenticated API requests. To retrieve an access token your application needs to make an HTTP POST request to the token endpoint of the auth system.
The token endpoint is located in the discovery document `token_endpoint` key.

To make this request, the application must create a standard HTTP basic authentication header with the `client_id` as the user name and `client_secret` as the password.

#### Request
The request must contain the following form-urlencoded parameter:

| Parameter | Description |
|-----------|-------------|
| grant_type | This must contain the value `client_credentials` as specified by the OAuth 2 specification. |

The raw HTTP request may look like this:

```
POST /oauth2/token HTTP/1.1
Host: accounts.pdk.io
Content-Type: application/x-www-form-urlencoded
Basic MmE2NmEzNzlkZjgzYjU1NzE2YTNhZWU5Mjk0ZWYxNjU6eW91cl9jbGllbnRfc2VjcmV0

grant_type=client_credentials
```

#### Response

The response to the POST request is JSON formatted data containing the access, and id tokens.

| Value | Description |
|-------|-------------|
| access_token | The access token that may now be used for making authenticated API requests. |
| id_token |  This is an encoded JWT that contains information on the authenticated user. It is described in more detail later. |
| token_type | The type of access token returned, this is currently always `Bearer`. |
| expires_in | Expiration time of the Access Token in seconds since the response was generated |

An example JSON encoded response may look like this:

```
{
  "access_token":"SlAV32hkKG"
  "id_token":"eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9...GmUdC2H13YMCwc30Z3l5RCrbwQ",
  "token_type":"Bearer",
  "expires_in": 3600
}
```

> *NOTE*: This authentication flow does not require the use of refresh tokens as the client can retrieve a fresh token from the token endpoint, without user-interaction, at any time.

### 2. Make API Requests
Now that your application has a valid access token it cannt  be used to make authenticated requests to PDK APIs.
This is done by simply including the access token in the Bearer type Authorization header of your requests.

The Authorization header should look similar to:

    Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9...GmUdC2H13YMCwc30Z3l5RCrbwQ



## Implicit Client Flow

The [Implicit Flow](http://openid.net/specs/openid-connect-implicit-1_0.html) is intended for Clients, such as client-side javascript applications, that cannot securely maintain a Client Secret between themselves and the Authorization Server.

### 1. Authenticate User
The URL to direct the user to can be found in the discovery document `authorization_endpoint` key.

There are a number of querystring parameters that must be included in this URL to properly authenticate the user and generate the authorization tokens.

|Parameter | Value | Description |
|----------|-------|-------------|
| response_type | id_token token | This requests that both an Access Token and an ID Token be returned from the Authorization Endpoint |
| client_id | The `client_id` assigned to your application | This identifies the application that is requesting access to the user's data |
| redirect_uri | The value to tell the auth system how to return the code | This determines how the access code is communcated to the application. You may choose between `urn:ietf:wg:oauth:2.0:oob` or `http://localhost` with a port number. This is covered in more detail below. |
| scope | openid | This is for future use and should only contain the value `openid` for now. |
| state | Any value | This is not required, but is available to round-trip any state information that may be useful to your application. This value should be secured against modification. |
| login_hint | email address or sub id | If your application knows what user is authenticating, this parameter will be used by the authentication system to pre-fill the login email. |
| nonce | A cryptographically unique one-time-use token | To mitigate replay attacks, this token must have sufficient entropy. The hash of a cryptographically random value stored in local storage should be sufficient. This is forwarded, unchanged inside the id token, back to the client and should be verified. |

#### Example URL

    https://accounts.pdk.io/oauth2/auth?
        response_type=id_token%20token&
        client_id=2a66a379df83b55716a3aee9294ef165&
        redirect_uri=https://myapp.example.com/cb&
        scope=openid&
        state=af0ifjsldkj
        nonce=n-0S6_WzA2Mj

### 2. Receive Token Response
Once the user successfully authenticates, their user-agent will be redirected back to your client's `redirect_uri`. The tokens and other authentication information are included in the fragment portion of the URI, this is mainly so that those values are not captured in webserver logs.

| Value | Description |
|-------|-------------|
| access_token | The access token that may now be used for making authenticated API requests. |
| token_type | The type of access token returned, this is currently always `Bearer`. |
| id_token |  This is an encoded JWT that contains information on the authenticated user. It is described in more detail later. |
| expires_in | Expiration time of the Access Token in seconds since the response was generated. |
| state | Client value included in the `state` parameter of the authentication request. |

    https://myapp.example.com/cb#
        access_token=SlAV32hkKG&
        token_type=bearer&
        id_token=eyJ0 ... NiJ9.eyJ1c ... I6IjIifX0.DeWt4Qu ... ZXso&
        expires_in=3600&
        state=af0ifjsldkj



# Token Types
## Access Token
This is an opaque authentication token that can be used to call the `user_info` endpoint found in the discovery document.
It should be placed in the Authorization header as a Bearer value.

## ID Token
This token is used for accessing the Accounts System APIs (Users, Panels, Org Units).

The ID token that is returned by the authentication flow is a JWT as specified in the [draft IETF standard](http://tools.ietf.org/html/draft-jones-json-web-token-10).
This token contains claims for the authenticated user, an issuer, a target audience, and an expiration time.
These claims include the user's roles, name, email, user id, and other attributes used to identify and authorize certain actions carried out on the user's behalf.

Since this token is digitally signed by the authentication system, the validity of the data in the token can easily be asserted and trusted.
The public keys for verifying the signature of the token are available at the `jwks_uri` key of the discovery document.

The body of a JWT may look like:

```
{
  "io.pdk.roles": [
    "admin",
    "user"
  ],
  "iat": 1402936513,
  "exp": 1402940113,
  "aud": "2a66a379df83b55716a3aee9294ef165",
  "iss": "io.pdk.accounts",
  "sub": "12345567",
  "at_hash": "MTIzNDU2Nzg5MDEyMzQ1Ng"
}
```

**! SECURITY CRITICAL:**
If you rely on data in this token for _any_ reason, be sure to get the certs and verify the signature properly.

If you are only using the token as an opaque Bearer for accessing PDK APIs, there is no need to verify the token in your application.

## Refresh Tokens
When an access token expires the application will need a new one.

If the application requests the scope `offline_access` through any auth flow that supports a refresh token, then a refresh token is provided in the auth flow response. This refresh token is used to request fresh access tokens from the auth system while the user is not actively using the system.

The refresh token should be saved in **secure** durable storage, as it expires only if the user or PDK revokes access to the application.

Applications that require `offline_access` should be quite rare as this is only needed for accessing the user's system while they are not actively using the requesting application.

## Token Lifetime
For security reasons, these tokens (except the refresh token) expire frequently and will cease to work after they expire.
The application will need to obtain a fresh token in order to continue making authenticated requests to API endpoints.
In the normal case, of an application that is not using `offline_access`, the application will need to process the auth flow in order to retrieve fresh tokens.

#### Request
Requesting a refresh token is very similar to exchanging an authorization code for an access token.
Your application will need to make an HTTP POST request to the token endpoint which can be found in the discovery document `token_endpoint` key.

To make this request, the application must use a standard HTTP basic authentication header with the `client_id` as the user name and `client_secret` as the password used to generate this header.

The request must contain a number of form-urlencoded parameters

| Parameter | Description |
|-----------|-------------|
| refresh_token | This is the persistent refresh token that your application should have received during the initial user authentication. |
| grant_type | This must contain the value `refresh_token` as specified by the OAuth 2 specification. |

The raw HTTP request may look like this:

```
POST /oauth2/token HTTP/1.1
Host: accounts.pdk.io
Content-Type: application/x-www-form-urlencoded
Basic MmE2NmEzNzlkZjgzYjU1NzE2YTNhZWU5Mjk0ZWYxNjU6eW91cl9jbGllbnRfc2VjcmV0

refresh_token=76c5cdeecfd1543cfd4c3e7c054780ac&
grant_type=refresh_token
```

#### Response

The response to the POST request is JSON formatted data containing the fresh access token.

| Value | Description |
|-------|-------------|
| id_token | The access token that may now be used for making authenticated API requests. This is an encoded JWT that is described in more detail later. |
| token_type | The type of access token returned, this is currently always `Bearer`.

An example JSON encoded response may look like this:

```
{
  "id_token":"eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9...GmUdC2H13YMCwc30Z3l5RCrbwQ",
  "token_type":"Bearer"
}
```

# Account System API

# Group Users
The User entity represents a user login identity used for authentication and authorization against the system.

# Group Panels
The Panel entity represents the configuration of the cloud node customer premise equipment.
This hardware hosts the PDK Panel API, and executes operations of the system at a site.

Registration and enumeration of panels is handled by operations on the OU entities since a panel can only exist as part of an OU.

The panel API endpoint can be resolved by getting the `uri` property of the panel document and appending the path `/api`.
This URI should look similar to `https://panel-1070bbb.pdk.io/api`.

For information on interacting with this API, see the [PDK Panel API documentation](https://pdkapi.docs.apiary.io/).

## Panel [/panels/{id}]
A distinct Panel entity.

+ Parameters

    + id (required, string, `10702MQ`) ... Alphanumeric `id` of the Panel to perform the action on.

+ Model (application/json)

    + `id` (required, string) ... The hardware serial number.
    + `name` (required, string) ... The user-readable name of the panel.
    + `uri` (required, string) ... The URI where the panel can be communicated with.
    + `notes` (required, string) ... User-defined notes.
    + `online` (required, boolean) ... The panel's online state.
    + `registeredDate` (required, string) ... Date and time that the panel was registered.

    + Body
    
              {
                 "id" : "10702GA",
                 "name" : "🏢 Main Office",
                 "uri" : "https://panel-10702GA.pdk.io/",
                 "notes" : "",
                 "online" : true,
                 "registeredDate" : "2016-04-20T17:29:03.510Z"
              }
    
### Retrieve a Panel [GET]

+ Response 200

    [Panel][]

### Update a Panel [PUT]
+ Response 204

### Deregister a Panel [DELETE]
+ Response 204

## Panel API Token [/panels/{id}/token]

To access the panel's API endpoint your applicaiton needs to have a valid, unexpired, and discrete auth token.

This token has a lifetime of 5 minutes, a fresh token must be retrieved in order to continue making requests to the panel API.
The limited lifetime works to limit the impact of an exposed token and allows timely revocation of access in a distributed authentication system.

+ Parameters
    + id (required, string, `10702MQ`) ... Alphanumeric `id` of the Panel to perform the action on.

### Generate an API Token [POST]

Generate a time-limited Bearer token for the current user's access to the panel's API.
This token will only work for accessing the panel specified in the `id` parameter.

If there was an unexpired token already generated for this user/panel, that token will be provided.

+ Response 200 (application/json)

        {
            "token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9...GmUdC2H13YMCwc30Z3l5RCrbwQ"
        }


# Group Organizational Units
The Organizational Unit entity is a heirarchical container of user Permissions, Panels, and child Organizational Units.
Each of these entities can only be a member of a single parent OU.

A User is assigned a Permission in an OU to access (according to their roles) all of the Permissions, Panels, and Organizations at their level and deeper in the heirarchy.

In the pdk.io web interface this entity is represented in the UI at `https://pdk.io/systems/{ou_id}`.
The **Customers** collection represents the children of the current OU.

## Organizational Unit [/ous/{ou_id}]

+ Parameters

    + ou_id (required, number) ... Numeric `id` of the OU to perform the action on.

+ Model (application/json)

    + Headers
    
                    
    + Body
    
            {
               "name" : "Integreat Inc.",
               "id" : "55ca2050bbed06f4348b26e8",
               "ancestors" : [
                  "544557759a01deb9874c02ef"
               ],
               "parent" : "544557759a01deb9874c02ef",
               "children" : [
                  {
                     "name" : "Production",
                     "permissions" : [
                        {
                           "role" : "integrator",
                           "userId" : "592457e5cb5f6f00011cc8ee",
                           "email" : "support@prodatakey.com",
                           "name" : "PDK Production",
                           "_id" : "592458c6f570e60001fcefe1"
                        }
                     ],
                     "id" : "592458bacb5f6f00011cc8f8",
                     "panels" : [
                        {
                           "name" : "Rack Mount",
                           "uri" : "https://panel-1070CIX.pdk.io/",
                           "registeredDate" : "2017-06-13T01:01:37.553Z",
                           "id" : "1070CIX"
                        }
                     ]
                  },
                  {
                     "name" : "R&R BBQ 🍖",
                     "id" : "581bac5b530b260001791b6b",
                     "panels" : [],
                     "permissions" : [
                        {
                           "email" : "josh+rr@pdk.io",
                           "userId" : "5821f293530b260001791d15",
                           "name" : "josh perry",
                           "_id" : "5821f277530b260001791d14",
                           "role" : "admin"
                        },
                        {
                           "role" : "manager",
                           "_id" : "5821f2c4530b260001791d17",
                           "name" : "josh perry",
                           "userId" : "5821f2e4530b260001791d18",
                           "email" : "josh+rrman@pdk.io"
                        },
                        {
                           "email" : "josh+rrad@pdk.io",
                           "userId" : "5821f37df4a93000014928fa",
                           "name" : "josh perry",
                           "_id" : "5821f353f4a93000014928f9",
                           "role" : "admin"
                        }
                     ]
                  },
                  {
                     "name" : "🎣 Joe's Bait Shop",
                     "panels" : [],
                     "id" : "57604b80a6a44c1200dba0c9",
                     "permissions" : []
                  }
               ],
               "permissions" : [
                  {
                     "email" : "jordan.mack@gmail.com",
                     "userId" : "584ac92b10e97a0001dbf4d8",
                     "name" : "Jordan Mack",
                     "_id" : "584aca3b10e97a0001dbf4da",
                     "role" : "reporter"
                  },
                  {
                     "role" : "manager",
                     "_id" : "598b6ad6ecb0770001abc31a",
                     "name" : "Greg Corp",
                     "userId" : "57d89535a5f887000195710b",
                     "email" : "gregcorp@xmission.com"
                  }
               ],
               "panels" : [
                  {
                     "uri" : "https://panel-10702GA.pdk.io/",
                     "online" : true,
                     "name" : "🏢 Main Office",
                     "id" : "10702GA",
                     "notes" : "",
                     "registeredDate" : "2016-04-20T17:29:03.510Z"
                  }
               ]
            }

### My OU [GET /ous/mine]

This represents the OU where the currently authenticated user is assigned permission and is commonly used as a root to enumerate all of the entities a user has access to.

+ Response 200

    [Organizational Unit][]

        
### Retrieve an OU [GET]

+ Response 200

    [Organizational Unit][]